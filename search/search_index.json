{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview What is SavedStateFlow? SavedStateFlow is a Kotlin StateFlow that can survive the Android process death. Why SavedStateFlow? SavedStateHandle is a great tool to persist state across the Android process death, however this only officially supports reactive updates through LiveData . There is a nice extension function that exists in the support library that can convert LiveData to a Flow , however using this directly in a ViewModel test requires setting up the test to work with LiveData and LiveData can technically have a null value. This is where SavedStateFlow comes in being a simple wrapper around SavedStateHandle.getLiveData() while enabling non null initial values exposing the state as a StateFlow . Basic Usage Inject a SavedStateFlowHandle into a ViewModel by using the extension function on SavedStateHandle . val savedStateHandle : SavedStateHandle = TODO () val savedStateFlowHandle : SavedStateFlowHandle = savedStateHandle . toSavedStateFlowHandle () Info Please refer to the samples to see how to get a reference to SavedStateHandle . manual injection using the AbstractSavedStateViewModelFactory The saved-state-flow-hilt artifact automatically scopes SavedStateFlowHandle to ViewModel 's so there is no need to get a reference to a SavedStateHandle . Once a SavedStateFlowHandle is created, inject it in a ViewModel and retrieve a SavedStateFlow . class MainViewModel ( savedStateFlowHandle : SavedStateFlowHandle , private val newsDataSource : NewsDataSource ) : ViewModel () { private val query : SavedStateFlow < String > = savedStateFlowHandle . getSavedStateFlow ( viewModelScope = viewModelScope , // scope for updates to be collected key = \"main-viewmodel-query-key\" , // unique key for the property defaultValue = \"\" // used when there is no previously saved value upon restoration ) init { observeQuery () } fun updateQuery ( query : String ) { this . query . value = query } private fun observeQuery () { viewModelScope . launch { query . asStateFlow () . flatMapLatest { query -> // fetch the results for the latest query newsDataSource . fetchQuery ( query ) } . collect { results -> // Update with the latest results } } } } Warning Since SavedStateFlow is a wrapper around SavedStateHandle , the following note from the documentation should be observed. State must be simple and lightweight. For complex or large data, you should use local persistence .","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#what-is-savedstateflow","text":"SavedStateFlow is a Kotlin StateFlow that can survive the Android process death.","title":"What is SavedStateFlow?"},{"location":"#why-savedstateflow","text":"SavedStateHandle is a great tool to persist state across the Android process death, however this only officially supports reactive updates through LiveData . There is a nice extension function that exists in the support library that can convert LiveData to a Flow , however using this directly in a ViewModel test requires setting up the test to work with LiveData and LiveData can technically have a null value. This is where SavedStateFlow comes in being a simple wrapper around SavedStateHandle.getLiveData() while enabling non null initial values exposing the state as a StateFlow .","title":"Why SavedStateFlow?"},{"location":"#basic-usage","text":"Inject a SavedStateFlowHandle into a ViewModel by using the extension function on SavedStateHandle . val savedStateHandle : SavedStateHandle = TODO () val savedStateFlowHandle : SavedStateFlowHandle = savedStateHandle . toSavedStateFlowHandle () Info Please refer to the samples to see how to get a reference to SavedStateHandle . manual injection using the AbstractSavedStateViewModelFactory The saved-state-flow-hilt artifact automatically scopes SavedStateFlowHandle to ViewModel 's so there is no need to get a reference to a SavedStateHandle . Once a SavedStateFlowHandle is created, inject it in a ViewModel and retrieve a SavedStateFlow . class MainViewModel ( savedStateFlowHandle : SavedStateFlowHandle , private val newsDataSource : NewsDataSource ) : ViewModel () { private val query : SavedStateFlow < String > = savedStateFlowHandle . getSavedStateFlow ( viewModelScope = viewModelScope , // scope for updates to be collected key = \"main-viewmodel-query-key\" , // unique key for the property defaultValue = \"\" // used when there is no previously saved value upon restoration ) init { observeQuery () } fun updateQuery ( query : String ) { this . query . value = query } private fun observeQuery () { viewModelScope . launch { query . asStateFlow () . flatMapLatest { query -> // fetch the results for the latest query newsDataSource . fetchQuery ( query ) } . collect { results -> // Update with the latest results } } } } Warning Since SavedStateFlow is a wrapper around SavedStateHandle , the following note from the documentation should be observed. State must be simple and lightweight. For complex or large data, you should use local persistence .","title":"Basic Usage"},{"location":"hilt-di/","text":"Hilt Dependency Injection Hilt is a dependency injection framework built on top of Dagger that helps reduce a lot of boiler plate when injecting dependencies. Hilt can also help reduce the boiler plate when using SavedStateFlow by scoping an instance of SavedStateFlowHandle to any ViewModel that requests it. Hilt ViewModel The saved-state-flow-hilt artifact provides an instance of SavedStateFlowHandle to the ViewModelComponent out of the box, so it can be declared in any ViewModel constructor like so. @HiltViewModel class MainViewModel @Inject constructor ( savedStateFlowHandle : SavedStateFlowHandle , private val newsDataSource : NewsDataSource ) : ViewModel () { private val query : SavedStateFlow < String > = savedStateFlowHandle . getSavedStateFlow ( viewModelScope , \"main-viewmodel-query-key\" , \"\" ) init { observeQuery () } fun updateQuery ( query : String ) { this . query . value = query } private fun observeQuery () { viewModelScope . launch { query . asStateFlow () . flatMapLatest { query -> newsDataSource . fetchQuery ( query ) } . collect { results -> // TODO update state with latest results } } } } The full version of this ViewModel can be found here . Grabbing a Reference to @HiltViewModel Finally grab a reference to the ViewModel using the by viewmodels { } delegation function. @AndroidEntryPoint class MainActivity : ComponentActivity () { private val viewModel : MainViewModel by viewModels () } Assisted Injection When using Hilt, it's possible that the @HiltViewModel annotation cannot be used when a value needs to be injected into the constructor at runtime. For that, there are a couple of extension methods provided to help inject a SavedStateFlowHandle when using Hilt's assisted injection from a FragmentActivity or Fragment . Assisted Injected ViewModel class MyAssistedViewModel @AssistedInject constructor ( @Assisted savedStateFlowHandle : SavedStateFlowHandle , @Assisted id : String ) : ViewModel () { @AssistedFactory interface Factory { fun create ( savedStateFlowHandle : SavedStateFlowHandle , id : String ): MyAssistedViewModel } } Grab a reference to an Assisted ViewModel Then in a Fragment or a FragmentActivity , the by assistedViewModel method may be used to get a reference to a assisted injected ViewModel as this method provides you an instance of a SavedStateFlowHandle . There is also a method for fragments to get a ViewModel scoped to its FragmentActivity if using the by assistedActivityViewModel {} method. @AndroidEntryPoint class AssistedFragment : Fragment () { @Inject lateinit var factory : MyAssistedViewModel . Factory private val viewModel : MyAssistedViewModel by assistedViewModel { savedStateFlowHandle -> factory . create ( savedStateFlowHandle , arguments ?. getString ( \"some-argument-key\" ) !! ) } } Resources Hilt sample source code","title":"Hilt"},{"location":"hilt-di/#hilt-dependency-injection","text":"Hilt is a dependency injection framework built on top of Dagger that helps reduce a lot of boiler plate when injecting dependencies. Hilt can also help reduce the boiler plate when using SavedStateFlow by scoping an instance of SavedStateFlowHandle to any ViewModel that requests it.","title":"Hilt Dependency Injection"},{"location":"hilt-di/#hilt-viewmodel","text":"The saved-state-flow-hilt artifact provides an instance of SavedStateFlowHandle to the ViewModelComponent out of the box, so it can be declared in any ViewModel constructor like so. @HiltViewModel class MainViewModel @Inject constructor ( savedStateFlowHandle : SavedStateFlowHandle , private val newsDataSource : NewsDataSource ) : ViewModel () { private val query : SavedStateFlow < String > = savedStateFlowHandle . getSavedStateFlow ( viewModelScope , \"main-viewmodel-query-key\" , \"\" ) init { observeQuery () } fun updateQuery ( query : String ) { this . query . value = query } private fun observeQuery () { viewModelScope . launch { query . asStateFlow () . flatMapLatest { query -> newsDataSource . fetchQuery ( query ) } . collect { results -> // TODO update state with latest results } } } } The full version of this ViewModel can be found here .","title":"Hilt ViewModel"},{"location":"hilt-di/#grabbing-a-reference-to-hiltviewmodel","text":"Finally grab a reference to the ViewModel using the by viewmodels { } delegation function. @AndroidEntryPoint class MainActivity : ComponentActivity () { private val viewModel : MainViewModel by viewModels () }","title":"Grabbing a Reference to @HiltViewModel"},{"location":"hilt-di/#assisted-injection","text":"When using Hilt, it's possible that the @HiltViewModel annotation cannot be used when a value needs to be injected into the constructor at runtime. For that, there are a couple of extension methods provided to help inject a SavedStateFlowHandle when using Hilt's assisted injection from a FragmentActivity or Fragment .","title":"Assisted Injection"},{"location":"hilt-di/#assisted-injected-viewmodel","text":"class MyAssistedViewModel @AssistedInject constructor ( @Assisted savedStateFlowHandle : SavedStateFlowHandle , @Assisted id : String ) : ViewModel () { @AssistedFactory interface Factory { fun create ( savedStateFlowHandle : SavedStateFlowHandle , id : String ): MyAssistedViewModel } }","title":"Assisted Injected ViewModel"},{"location":"hilt-di/#grab-a-reference-to-an-assisted-viewmodel","text":"Then in a Fragment or a FragmentActivity , the by assistedViewModel method may be used to get a reference to a assisted injected ViewModel as this method provides you an instance of a SavedStateFlowHandle . There is also a method for fragments to get a ViewModel scoped to its FragmentActivity if using the by assistedActivityViewModel {} method. @AndroidEntryPoint class AssistedFragment : Fragment () { @Inject lateinit var factory : MyAssistedViewModel . Factory private val viewModel : MyAssistedViewModel by assistedViewModel { savedStateFlowHandle -> factory . create ( savedStateFlowHandle , arguments ?. getString ( \"some-argument-key\" ) !! ) } }","title":"Grab a reference to an Assisted ViewModel"},{"location":"hilt-di/#resources","text":"Hilt sample source code","title":"Resources"},{"location":"manual-di/","text":"Manual Dependency Injection When creating a simple app making use of the AbstractSavedStateViewModelFactory to manually inject dependencies, this section showcases a sample using that. ViewModel A paired down version of the ViewModel for this sample is shown below: class MainViewModel ( savedStateFlowHandle : SavedStateFlowHandle , private val newsDataSource : NewsDataSource ) : ViewModel () { private val query : SavedStateFlow < String > = savedStateFlowHandle . getSavedStateFlow ( viewModelScope , \"main-viewmodel-query-key\" , \"\" ) init { observeQuery () } fun updateQuery ( query : String ) { this . query . value = query } private fun observeQuery () { viewModelScope . launch { query . asStateFlow () . flatMapLatest { query -> newsDataSource . fetchQuery ( query ) } . collect { results -> //TODO update state } } } } The full version of this ViewModel can be found here . ViewModel Factory Now to actually create an instance of the ViewModel and provide it an instance of SavedStateFlowHandle , create a factory class that extends AbstractSavedStateViewModelFactory and make use of the extension function SavedStateHandle.toSavedStateFlowHandle() . class MainViewModelFactory ( owner : SavedStateRegistryOwner , defaultArgs : Bundle? = null ) : AbstractSavedStateViewModelFactory ( owner , defaultArgs ) { override fun < T : ViewModel ? > create ( key : String , modelClass : Class < T > , handle : SavedStateHandle ): T { return MainViewModel ( handle . toSavedStateFlowHandle (), NewsRepository ) as T } } Grabbing a Reference to ViewModel Finally an instance of a ViewModel can be grabbed from the view using the by viewmodels { } delegation function and passing it an instance of the factory. class MainActivity : ComponentActivity () { private val viewModel : MainViewModel by viewModels { MainViewModelFactory ( this ) } } Resources Manual DI sample source code Suggestion Manual dependency injection is great for small apps and for understanding the basic concept, however it can lead to writing a lot of boiler plate code creating ViewModel factory classes. To help reduce the amount of boiler plate, you can move onto the next section to see how a dependency injection framework like Hilt can be used with SavedStateFlow .","title":"Manual DI"},{"location":"manual-di/#manual-dependency-injection","text":"When creating a simple app making use of the AbstractSavedStateViewModelFactory to manually inject dependencies, this section showcases a sample using that.","title":"Manual Dependency Injection"},{"location":"manual-di/#viewmodel","text":"A paired down version of the ViewModel for this sample is shown below: class MainViewModel ( savedStateFlowHandle : SavedStateFlowHandle , private val newsDataSource : NewsDataSource ) : ViewModel () { private val query : SavedStateFlow < String > = savedStateFlowHandle . getSavedStateFlow ( viewModelScope , \"main-viewmodel-query-key\" , \"\" ) init { observeQuery () } fun updateQuery ( query : String ) { this . query . value = query } private fun observeQuery () { viewModelScope . launch { query . asStateFlow () . flatMapLatest { query -> newsDataSource . fetchQuery ( query ) } . collect { results -> //TODO update state } } } } The full version of this ViewModel can be found here .","title":"ViewModel"},{"location":"manual-di/#viewmodel-factory","text":"Now to actually create an instance of the ViewModel and provide it an instance of SavedStateFlowHandle , create a factory class that extends AbstractSavedStateViewModelFactory and make use of the extension function SavedStateHandle.toSavedStateFlowHandle() . class MainViewModelFactory ( owner : SavedStateRegistryOwner , defaultArgs : Bundle? = null ) : AbstractSavedStateViewModelFactory ( owner , defaultArgs ) { override fun < T : ViewModel ? > create ( key : String , modelClass : Class < T > , handle : SavedStateHandle ): T { return MainViewModel ( handle . toSavedStateFlowHandle (), NewsRepository ) as T } }","title":"ViewModel Factory"},{"location":"manual-di/#grabbing-a-reference-to-viewmodel","text":"Finally an instance of a ViewModel can be grabbed from the view using the by viewmodels { } delegation function and passing it an instance of the factory. class MainActivity : ComponentActivity () { private val viewModel : MainViewModel by viewModels { MainViewModelFactory ( this ) } }","title":"Grabbing a Reference to ViewModel"},{"location":"manual-di/#resources","text":"Manual DI sample source code Suggestion Manual dependency injection is great for small apps and for understanding the basic concept, however it can lead to writing a lot of boiler plate code creating ViewModel factory classes. To help reduce the amount of boiler plate, you can move onto the next section to see how a dependency injection framework like Hilt can be used with SavedStateFlow .","title":"Resources"},{"location":"setup/","text":"Setup SavedStateFlow SavedStateFlow is available through Maven Central so declare that in the root build.gradle . Groovy Kotlin buildscript { repositories { mavenCentral () } } buildscript { repositories { mavenCentral () } } For all artifacts listed below, replace <version> with the latest version available on Maven Central or check out releases for previous versions. For example: implementation \"com.plusmobileapps:saved-state-flow:1.0\" SavedStateFlow For the basic SavedStateFlow API that could be used in any dependency injection framework, please import the following. Groovy Kotlin implementation \"com.plusmobileapps:saved-state-flow:<version>\" implementation ( \"com.plusmobileapps:saved-state-flow:<version>\" ) SavedStateFlow - Hilt If using Hilt , this is the only dependency that needs to be imported as it bundles in the SavedStateFlow API and allows SavedStateFlowHandle to be injected into any @HiltViewModel . Groovy Kotlin implementation \"com.plusmobileapps:saved-state-flow-hilt:<version>\" implementation ( \"com.plusmobileapps:saved-state-flow-hilt:<version>\" ) Testing For the TestSavedStateFlow artifact, import the following for testing. Groovy Kotlin testImplementation \"com.plusmobileapps:saved-state-flow-test:<version>\" testImplementation ( \"com.plusmobileapps:saved-state-flow-test:<version>\" )","title":"Setup"},{"location":"setup/#setup-savedstateflow","text":"SavedStateFlow is available through Maven Central so declare that in the root build.gradle . Groovy Kotlin buildscript { repositories { mavenCentral () } } buildscript { repositories { mavenCentral () } } For all artifacts listed below, replace <version> with the latest version available on Maven Central or check out releases for previous versions. For example: implementation \"com.plusmobileapps:saved-state-flow:1.0\"","title":"Setup SavedStateFlow"},{"location":"setup/#savedstateflow","text":"For the basic SavedStateFlow API that could be used in any dependency injection framework, please import the following. Groovy Kotlin implementation \"com.plusmobileapps:saved-state-flow:<version>\" implementation ( \"com.plusmobileapps:saved-state-flow:<version>\" )","title":"SavedStateFlow"},{"location":"setup/#savedstateflow-hilt","text":"If using Hilt , this is the only dependency that needs to be imported as it bundles in the SavedStateFlow API and allows SavedStateFlowHandle to be injected into any @HiltViewModel . Groovy Kotlin implementation \"com.plusmobileapps:saved-state-flow-hilt:<version>\" implementation ( \"com.plusmobileapps:saved-state-flow-hilt:<version>\" )","title":"SavedStateFlow - Hilt"},{"location":"setup/#testing","text":"For the TestSavedStateFlow artifact, import the following for testing. Groovy Kotlin testImplementation \"com.plusmobileapps:saved-state-flow-test:<version>\" testImplementation ( \"com.plusmobileapps:saved-state-flow-test:<version>\" )","title":"Testing"},{"location":"testing/","text":"Testing The primary motivation for creating this library was to help make testing easier when working with SavedStateHandle.getLiveData() and converting this value to a Flow , then to a StateFlow . Without the abstraction SavedStateFlowHandle provides, one would have to use LiveData when testing and remember to always add the InstantTaskExecutorRule . If your app simply uses StateFlow to manage state, then needing to work with LiveData and adding this rule can increase the cognitive load when working in a project. TestSavedStateFlow Since the underlying implementation of SavedStateFlow is delegating to the SavedStateHandle , using the actual implementation would require using LiveData and InstantTaskExecutorRule . So to prevent the need of using either of those in tests, there is a test artifact that can be used called TestSavedStateFlow which simply swaps out the implementation with a MutableStateFlow . So one simple test using setup using TestSavedStateFlow might look like the following. The mocking library in the samples is Mockk . class SomeTest { @Test fun `some test` () = runBlocking { val savedStateHandle : SavedStateFlowHandle = mockk () val savedStateFlow = TestSavedStateFlow < String > ( defaultValue = \"\" , cachedValue = \"some cached value\" ) every { savedStateHandle . getSavedStateFlow ( any (), \"some-key\" , \"\" ) } returns savedStateFlow val viewModel = MyViewModel ( savedStateHandle ) // omitted test code } } Test Setup Both samples for manual DI and Hilt have the same constructor, therefore have the same test structure. So when setting up the test, a TestCoroutineTestRule is needed to override the main dispatcher being used by the viewModelScope . Then the following setup will be used to setup each of the following tests one could write using TestSavedStateFlow . class MainViewModelTest { @get : Rule var coroutinesTestRule = TestCoroutinesRule () private lateinit var viewModel : MainViewModel private val savedStateHandle : SavedStateFlowHandle = mockk () private val newsDataSource : NewsDataSource = mockk () private val results = listOf < String > ( \"some value\" , \"some second value\" ) private fun setUp ( savedStateFlow : SavedStateFlow < String > ) { every { newsDataSource . fetchQuery ( \"\" ) } returns flow { } every { savedStateHandle . getSavedStateFlow ( any (), SAVED_STATE_QUERY_KEY , \"\" ) } returns savedStateFlow viewModel = MainViewModel ( savedStateHandle , newsDataSource ) } } Then to actually test the values emitted by the Flow , Turbine is a great testing library for verifying values emitted by a Flow . Test Default Value The cachedValue has a default value of null, so that can be omitted in tests not concerned with a cached value when restoring from a process death and just use the defaultValue . @Test fun `default value test` () { val savedStateFlow = TestSavedStateFlow < String > ( \"some default value\" ) .... } Test Cached Value @Test fun `initial query value exists, should start in loading state and fetch results` () = runBlocking { val cachedQuery = \"some cached query\" val savedStateFlow = TestSavedStateFlow < String > ( \"\" , cachedQuery ) every { newsDataSource . fetchQuery ( cachedQuery ) } returns flowOf ( results ) setUp ( savedStateFlow ) viewModel . state . test { assertEquals ( State ( true , cachedQuery , emptyList ()), awaitItem ()) assertEquals ( State ( false , cachedQuery , results ), awaitItem ()) } } Test Value Changes @Test fun `update query should trigger a new fetch to the repository for results and update state` () = runBlocking { val savedStateFlow = TestSavedStateFlow < String > ( \"\" ) val newQuery = \"some new query\" every { newsDataSource . fetchQuery ( newQuery ) } returns flowOf ( results ) setUp ( savedStateFlow ) viewModel . state . test { viewModel . updateQuery ( newQuery ) assertEquals ( State ( false , \"\" , emptyList ()), awaitItem ()) assertEquals ( State ( true , newQuery , emptyList ()), awaitItem ()) assertEquals ( State ( false , newQuery , results ), awaitItem ()) } } Resources TestSavedStateFlow source code Hilt sample test folder Manual DI sample test folder Turbine - A small testing library for kotlinx.coroutines Flow Mockk - Kotlin mocking library","title":"Testing"},{"location":"testing/#testing","text":"The primary motivation for creating this library was to help make testing easier when working with SavedStateHandle.getLiveData() and converting this value to a Flow , then to a StateFlow . Without the abstraction SavedStateFlowHandle provides, one would have to use LiveData when testing and remember to always add the InstantTaskExecutorRule . If your app simply uses StateFlow to manage state, then needing to work with LiveData and adding this rule can increase the cognitive load when working in a project.","title":"Testing"},{"location":"testing/#testsavedstateflow","text":"Since the underlying implementation of SavedStateFlow is delegating to the SavedStateHandle , using the actual implementation would require using LiveData and InstantTaskExecutorRule . So to prevent the need of using either of those in tests, there is a test artifact that can be used called TestSavedStateFlow which simply swaps out the implementation with a MutableStateFlow . So one simple test using setup using TestSavedStateFlow might look like the following. The mocking library in the samples is Mockk . class SomeTest { @Test fun `some test` () = runBlocking { val savedStateHandle : SavedStateFlowHandle = mockk () val savedStateFlow = TestSavedStateFlow < String > ( defaultValue = \"\" , cachedValue = \"some cached value\" ) every { savedStateHandle . getSavedStateFlow ( any (), \"some-key\" , \"\" ) } returns savedStateFlow val viewModel = MyViewModel ( savedStateHandle ) // omitted test code } }","title":"TestSavedStateFlow"},{"location":"testing/#test-setup","text":"Both samples for manual DI and Hilt have the same constructor, therefore have the same test structure. So when setting up the test, a TestCoroutineTestRule is needed to override the main dispatcher being used by the viewModelScope . Then the following setup will be used to setup each of the following tests one could write using TestSavedStateFlow . class MainViewModelTest { @get : Rule var coroutinesTestRule = TestCoroutinesRule () private lateinit var viewModel : MainViewModel private val savedStateHandle : SavedStateFlowHandle = mockk () private val newsDataSource : NewsDataSource = mockk () private val results = listOf < String > ( \"some value\" , \"some second value\" ) private fun setUp ( savedStateFlow : SavedStateFlow < String > ) { every { newsDataSource . fetchQuery ( \"\" ) } returns flow { } every { savedStateHandle . getSavedStateFlow ( any (), SAVED_STATE_QUERY_KEY , \"\" ) } returns savedStateFlow viewModel = MainViewModel ( savedStateHandle , newsDataSource ) } } Then to actually test the values emitted by the Flow , Turbine is a great testing library for verifying values emitted by a Flow .","title":"Test Setup"},{"location":"testing/#test-default-value","text":"The cachedValue has a default value of null, so that can be omitted in tests not concerned with a cached value when restoring from a process death and just use the defaultValue . @Test fun `default value test` () { val savedStateFlow = TestSavedStateFlow < String > ( \"some default value\" ) .... }","title":"Test Default Value"},{"location":"testing/#test-cached-value","text":"@Test fun `initial query value exists, should start in loading state and fetch results` () = runBlocking { val cachedQuery = \"some cached query\" val savedStateFlow = TestSavedStateFlow < String > ( \"\" , cachedQuery ) every { newsDataSource . fetchQuery ( cachedQuery ) } returns flowOf ( results ) setUp ( savedStateFlow ) viewModel . state . test { assertEquals ( State ( true , cachedQuery , emptyList ()), awaitItem ()) assertEquals ( State ( false , cachedQuery , results ), awaitItem ()) } }","title":"Test Cached Value"},{"location":"testing/#test-value-changes","text":"@Test fun `update query should trigger a new fetch to the repository for results and update state` () = runBlocking { val savedStateFlow = TestSavedStateFlow < String > ( \"\" ) val newQuery = \"some new query\" every { newsDataSource . fetchQuery ( newQuery ) } returns flowOf ( results ) setUp ( savedStateFlow ) viewModel . state . test { viewModel . updateQuery ( newQuery ) assertEquals ( State ( false , \"\" , emptyList ()), awaitItem ()) assertEquals ( State ( true , newQuery , emptyList ()), awaitItem ()) assertEquals ( State ( false , newQuery , results ), awaitItem ()) } }","title":"Test Value Changes"},{"location":"testing/#resources","text":"TestSavedStateFlow source code Hilt sample test folder Manual DI sample test folder Turbine - A small testing library for kotlinx.coroutines Flow Mockk - Kotlin mocking library","title":"Resources"}]}